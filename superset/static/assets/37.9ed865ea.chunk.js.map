{"version":3,"sources":["webpack:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js","webpack:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js","webpack:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css?d2c4","webpack:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js","webpack:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js","webpack:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACoB;AACe;AAC6B;AACR;AACP;AACJ;AAC7C;AACA,6BAA6B,yCAAyC;AACtE,QAAQ,iDAAS,SAAS,iDAAS;AACnC,SAAS,iDAAS;AAClB,UAAU,iDAAS;AACnB,eAAe,iDAAS;AACxB,iBAAiB,iDAAS;AAC1B,qBAAqB,iDAAS;AAC9B,WAAW,iDAAS,SAAS,iDAAS;AACtC,UAAU,iDAAS;AACnB,iBAAiB,iDAAS;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mCAAmC,iEAA2B,4CAA4C,yCAAE;;AAE5G;;AAEA,oBAAoB,yCAAE;AACtB;AACA;AACA,yDAAyD,UAAU;AACnE,gBAAgB,8EAAS;;AAEzB;AACA;AACA,iBAAiB,yEAAO;AACxB,+CAA+C,UAAU;AACzD;AACA;AACA,OAAO;;AAEP;AACA,KAAK,EAAE;;AAEP;AACA,MAAM,yCAAE;AACR;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACe,kFAAmB,E;;;;;;;;;;;;AC5FlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AAC2B;AAClB;AACW;AACQ;AACtD,uBAAuB,iEAAQ,CAAC,4DAAS;;AAEzC;AACA;AACA;AACA,CAAC,KAAK,0DAAa;AACnB;AACA,CAAC,EAAE,0DAAa;;AAEhB;AACA,aAAa,iDAAS;AACtB;AACe,+HAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;AC9CD,cAAc,mBAAO,CAAC,+MAAmE;;AAEzF;AACA,cAAc,QAAS;AACvB;;AAEA;;AAEA;AACA;;AAEA,aAAa,mBAAO,CAAC,kJAAuE;;AAE5F;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;;AAEA;AACe;AACf;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iBAAiB;AACjB,mBAAmB;AACnB;AACA;AACA;AACA;AACA,UAAU;AACV,iBAAiB;AACjB,4BAA4B;;;AAG5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG,EAAE;;AAEL;AACA,mBAAmB;;AAEnB,yBAAyB;;AAEzB,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,uBAAuB;AACvB,wBAAwB;AACxB;;AAEA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK,EAAE;;;AAGP,oCAAoC;;AAEpC,0KAA0K;;AAE1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC,mDAAmD;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,aAAa;AACb,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,GAAG;;;AAGH;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,sEAAsE;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA+D;AAC/D;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA,KAAK;AACL;AACA,KAAK,EAAE;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE;;AAEpE;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,uFAAuF;;AAE5F;AACA;AACA;AACA,KAAK;AACL,6JAA6J;;AAE7J;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;;;AAGA;AACA;;AAEA;AACA,0EAA0E;AAC1E;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA,KAAK,EAAE;AACP;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,mCAAmC;AACnC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP,4CAA4C;;AAE5C;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,IAAI;;;AAGJ;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,OAAO,EAAE;AACT;AACA;AACA;AACA;;;AAGA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qCAAqC;;AAErC,sCAAsC;;AAEtC;AACA;AACA,SAAS,EAAE;;;AAGX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG,IAAI;AACP;;;AAGA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;;AAEA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO,EAAE;;AAET,+IAA+I;;AAE/I;AACA,4GAA4G;AAC5G;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA,OAAO,EAAE;AACT;AACA;AACA;AACA;;;AAGA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;;AAEb;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;;AAEb;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG,IAAI;AACP;;;AAGA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG;;;AAGR;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;;AAEA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,EAAE;;AAEX;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO,EAAE;;AAET,6IAA6I;;AAE7I;AACA,sGAAsG;AACtG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA,wFAAwF;;AAExF,yCAAyC;;AAEzC,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;;;AAGT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;;AAEA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,E;;;;;;;;;;;;ACvjEA;AAAA;;AAEA;AACA;AACe;AACf;;AAEA;AACA,uEAAuE;;AAEvE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,2BAA2B;;AAE3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,EAAE;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;AChDA,2BAA2B,mBAAO,CAAC,4FAA2C;AAC9E;;;AAGA;AACA,cAAc,QAAS,4DAA4D,oBAAoB,uBAAuB,GAAG,uBAAuB,yBAAyB,GAAG,2BAA2B,eAAe,oBAAoB,iBAAiB,GAAG,gCAAgC,sBAAsB,GAAG,oCAAoC,mCAAmC,GAAG,2BAA2B,6BAA6B,GAAG,0BAA0B,oCAAoC,+BAA+B,GAAG,iDAAiD,eAAe,iBAAiB,gCAAgC,GAAG,qBAAqB,eAAe,kCAAkC,qCAAqC,gCAAgC,GAAG,2BAA2B,kBAAkB,GAAG,cAAc,gCAAgC,8BAA8B,6BAA6B,2BAA2B,0BAA0B,sBAAsB,4BAA4B,GAAG,mEAAmE,gBAAgB,oBAAoB,sBAAsB,iBAAiB,gBAAgB,GAAG,kCAAkC,oCAAoC,GAAG,sBAAsB,sBAAsB,GAAG,oBAAoB,gBAAgB,qBAAqB,wBAAwB,iBAAiB,iBAAiB,GAAG,qBAAqB,iBAAiB,GAAG,UAAU,oOAAoO,OAAO,YAAY,aAAa,MAAM,KAAK,YAAY,OAAO,KAAK,UAAU,YAAY,WAAW,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,YAAY,aAAa,MAAM,MAAM,UAAU,UAAU,YAAY,MAAM,KAAK,UAAU,YAAY,aAAa,aAAa,MAAM,KAAK,UAAU,KAAK,KAAK,YAAY,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,OAAO,YAAY,OAAO,UAAU,YAAY,aAAa,WAAW,UAAU,KAAK,KAAK,YAAY,MAAM,KAAK,YAAY,MAAM,KAAK,UAAU,YAAY,aAAa,WAAW,UAAU,KAAK,KAAK,UAAU,4GAA4G,oBAAoB,uBAAuB,GAAG,uBAAuB,yBAAyB,GAAG,2BAA2B,eAAe,oBAAoB,iBAAiB,GAAG,gCAAgC,sBAAsB,GAAG,oCAAoC,mCAAmC,GAAG,2BAA2B,6BAA6B,GAAG,0BAA0B,oCAAoC,+BAA+B,GAAG,iDAAiD,eAAe,iBAAiB,gCAAgC,GAAG,qBAAqB,eAAe,kCAAkC,qCAAqC,gCAAgC,GAAG,2BAA2B,kBAAkB,GAAG,cAAc,gCAAgC,8BAA8B,6BAA6B,2BAA2B,0BAA0B,sBAAsB,4BAA4B,GAAG,mEAAmE,gBAAgB,oBAAoB,sBAAsB,iBAAiB,gBAAgB,GAAG,kCAAkC,oCAAoC,GAAG,sBAAsB,sBAAsB,GAAG,oBAAoB,gBAAgB,qBAAqB,wBAAwB,iBAAiB,iBAAiB,GAAG,qBAAqB,iBAAiB,GAAG,qBAAqB;;AAEj2H","file":"37.9ed865ea.chunk.js","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* eslint-disable react/sort-prop-types */\nimport d3 from 'd3';\nimport PropTypes from 'prop-types';\nimport { getSequentialSchemeRegistry } from '@superset-ui/core';\nimport parcoords from './vendor/parcoords/d3.parcoords';\nimport divgrid from './vendor/parcoords/divgrid';\nimport './vendor/parcoords/d3.parcoords.css';\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: PropTypes.arrayOf(PropTypes.object),\n  width: PropTypes.number,\n  height: PropTypes.number,\n  colorMetric: PropTypes.string,\n  includeSeries: PropTypes.bool,\n  linearColorScheme: PropTypes.string,\n  metrics: PropTypes.arrayOf(PropTypes.string),\n  series: PropTypes.string,\n  showDatatable: PropTypes.bool\n};\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable\n  } = props;\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach(v => {\n    ttypes[v] = 'number';\n  });\n  const colorScale = colorMetric ? getSequentialSchemeRegistry().get(linearColorScheme).createLinearScale(d3.extent(data, d => d[colorMetric])) : () => 'grey';\n\n  const color = d => colorScale(d[colorMetric]);\n\n  const container = d3.select(element).classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n  const div = container.append('div').style('height', `${effHeight}px`).classed('parcoords', true);\n  const chart = parcoords()(div.node()).width(width).color(color).alpha(0.5).composite('darken').height(effHeight).data(data).dimensions(cols).types(ttypes).render().createAxes().shadows().reorderable().brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = divgrid();\n    container.append('div').style('height', `${effHeight}px`).datum(data).call(grid).classed('parcoords grid', true).selectAll('.row').on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n\n      mouseout: chart.unhighlight\n    }); // update data table on brush event\n\n    chart.on('brush', d => {\n      d3.select('.grid').datum(d).call(grid).selectAll('.row').on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n\n        mouseout: chart.unhighlight\n      });\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;\nexport default ParallelCoordinates;","/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport React from 'react';\nimport { styled, reactify } from '@superset-ui/core';\nimport PropTypes from 'prop-types';\nimport Component from './ParallelCoordinates';\nimport { jsx as ___EmotionJSX } from \"@emotion/react\";\nconst ReactComponent = reactify(Component);\n\nconst ParallelCoordianes = ({\n  className,\n  ...otherProps\n}) => ___EmotionJSX(\"div\", {\n  className: className\n}, ___EmotionJSX(ReactComponent, otherProps));\n\nParallelCoordianes.propTypes = {\n  className: PropTypes.string.isRequired\n};\nexport default styled(ParallelCoordianes)`\n  .superset-legacy-chart-parallel-coordinates {\n    div.grid {\n      overflow: auto;\n      div.row {\n        &:hover {\n          background-color: #ccc;\n        }\n      }\n    }\n  }\n`;","var content = require(\"!!../../../../../css-loader/index.js??ref--7-1!./d3.parcoords.css\");\n\nif (typeof content === 'string') {\n  content = [[module.id, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = require(\"!../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n","/* [LICENSE TBD] */\n\n/* eslint-disable */\nexport default function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: {\n      top: 24,\n      right: 0,\n      bottom: 12,\n      left: 0\n    },\n    nullValueSeparator: 'undefined',\n    // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: {\n      top: 8,\n      right: 0,\n      bottom: 8,\n      left: 0\n    },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight; // canvas data layers\n\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    }); // svg tick and brush layers\n\n    pc.svg = selection.append('svg').attr('width', __.width).attr('height', __.height).append('svg:g').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')');\n    return pc;\n  };\n\n  var events = d3.dispatch.apply(this, ['render', 'resize', 'highlight', 'brush', 'brushend', 'axesreorder'].concat(d3.keys(__))),\n      w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n      h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n      flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false\n  },\n      xscale = d3.scale.ordinal(),\n      yscale = {},\n      dragging = {},\n      line = d3.svg.line(),\n      axis = d3.svg.axis().orient('left').ticks(5),\n      g,\n      // groups for axes, brushes\n  ctx = {},\n      canvas = {},\n      clusterCentroids = []; // side effects for setters\n\n\n  var side_effects = d3.dispatch.apply(this, d3.keys(__)).on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).on('width', function (d) {\n    pc.resize();\n  }).on('height', function (d) {\n    pc.resize();\n  }).on('margin', function (d) {\n    pc.resize();\n  }).on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  }); // expose the state of the chart\n\n  pc.state = __;\n  pc.flags = flags; // create getter/setters\n\n  getset(pc, __, events); // expose events\n\n  d3.rebind(pc, events, 'on'); // getter/setter with event firing\n\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        events[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n\n\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [h() + 1 - __.nullValueSeparatorPadding.bottom - __.nullValueSeparatorPadding.top, 1];\n    } else if (__.nullValueSeparator == 'top') {\n      return [h() + 1, 1 + __.nullValueSeparatorPadding.bottom + __.nullValueSeparatorPadding.top];\n    }\n\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n            domain = []; // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    }); // xscale\n\n\n    xscale.rangePoints([0, w()], 1); // canvas sizes\n\n    pc.selection.selectAll('canvas').style('margin-top', __.margin.top + 'px').style('margin-left', __.margin.left + 'px').attr('width', w() + 2).attr('height', h() + 2); // default styles, needs to be set when canvas width changes\n\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n\n    if (typeof global === 'undefined') {\n      global = true;\n    } // scales of the same type\n\n\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(scales.map(function (p, i) {\n        return yscale[p].domain();\n      }).reduce(function (a, b) {\n        return a.concat(b);\n      }));\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n      });\n    } // update centroids\n\n\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  }; // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n\n\n  pc.toType = function (v) {\n    return {}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n  }; // try to coerce to number before returning type\n\n\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n\n    return pc.toType(v);\n  }; // attempt to determine types of each dimension based on first row of data\n\n\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.renderQueue(path_foreground).rate(50).clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.renderQueue(path_brushed).rate(50).clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map(); // determine clusterCounts\n\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y])); // centroids on 'virtual' axes\n\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i]);\n\n          var rightCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i + 1]);\n\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n    cps.push(centroids[0]);\n    cps.push($V([centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)), centroids[0].e(2)]));\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n\n    cps.push($V([centroids[cols - 1].e(1) + a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)), centroids[cols - 1].e(2)]));\n    cps.push(centroids[cols - 1]);\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  }; // draw dots with radius r on the axis line where data intersects\n\n\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n\n    return this;\n  }; // draw single cubic bezier curve\n\n\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n\n      ctx.bezierCurveTo(cps[i].e(1), cps[i].e(2), cps[i + 1].e(1), cps[i + 1].e(2), cps[i + 2].e(1), cps[i + 2].e(2));\n    }\n  } // draw single polyline\n\n\n  function color_path(d, ctx) {\n    ctx.beginPath();\n\n    if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n\n    ctx.stroke();\n  } // draw many polylines of the same color\n\n\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  } // returns the y-position just beyond the separating null value line\n\n\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n    }\n\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      } else {\n        ctx.lineTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2); // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n\n    return this;\n  };\n\n  d3.rebind(pc, axis, 'ticks', 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n    pc.flip(dimension);\n    d3.select(this.parentElement).transition().duration(1100).call(axis.scale(yscale[dimension]));\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n    __.dimensionTitleRotation += delta;\n    pc.svg.selectAll('text.label').attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes(); // Add a group element for each dimension.\n\n    g = pc.svg.selectAll('.dimension').data(__.dimensions, function (d) {\n      return d;\n    }).enter().append('svg:g').attr('class', 'dimension').attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    }); // Add an axis and title.\n\n    g.append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', 1 + __.nullValueSeparatorPadding.top).attr('x2', w()).attr('y2', 1 + __.nullValueSeparatorPadding.top).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('x2', w()).attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions); // Enter\n\n    g_data.enter().append('svg:g').attr('class', 'dimension').attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 0).append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels); // Update\n\n    g_data.attr('opacity', 0);\n    g_data.select('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.select('.label').transition().duration(1100).text(dimensionLabels).attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'); // Exit\n\n    g_data.exit().remove();\n    g = pc.svg.selectAll('.dimension');\n    g.transition().duration(1100).attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 1);\n    pc.svg.selectAll('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n\n    return this;\n  }; // Jason Davies, http://bl.ocks.org/1341281\n\n\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n    g.style('cursor', 'move').call(d3.behavior.drag().on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).on('drag', function (d) {\n      dragging[d] = Math.min(w(), Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions); // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).transition().attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n    flags.reorderable = true;\n    return this;\n  }; // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n\n\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]); // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n\n\n      return pixelDifference;\n    }); // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n\n\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n\n      var highlighted = __.highlighted.slice(0);\n\n      pc.unhighlight();\n      g.transition().duration(1500).attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render(); // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  }; // pairs of adjacent dimensions\n\n\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {},\n        // Nothing to be done.\n        uninstall: function (pc) {},\n        // Nothing to be done.\n        selected: function () {\n          return [];\n        },\n        // Nothing to return\n        brushState: function () {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    }\n  }; // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    } // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n\n\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      } // Next, we need to 'uninstall' the current brushMode.\n\n\n      brush.modes[brush.mode].uninstall(pc); // Finally, we can install the requested one.\n\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  }; // brush mode: 1D-Axes\n\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        string: function (d, p, dimension) {\n          return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        }); // loop over each dimension and update appropriately (if it was passed in through extents)\n\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]); //redraw the brush\n\n            brush(brushSelections[d]); //fire some events\n\n            brush.event(brushSelections[d]);\n          }\n        }); //redraw the chart\n\n\n        pc.renderBrushed();\n      }\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n\n  (function () {\n    var strums = {},\n        strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n          id = strum.dims.i,\n          points = [strum.p1, strum.p2],\n          line = svg.selectAll('line#strum-' + id).data([strum]),\n          circles = svg.selectAll('circle#strum-' + id).data(points),\n          drag = d3.behavior.drag();\n      line.enter().append('line').attr('id', 'strum-' + id).attr('class', 'strum');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(Math.max(strum.minX + 1, ev.x), strum.maxX);\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'strum-' + id).attr('class', 'strum');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            strum;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n        strums[dims.i] = strum;\n        strums.active = dims.i; // Make sure that the point is within the bounds\n\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            strum = strums[strums.active]; // Make sure that the point is within the bounds\n\n        strum.p2[0] = Math.min(Math.max(strum.minX + 1, ev.x - __.margin.left), strum.maxX);\n        strum.p2[1] = Math.min(Math.max(strum.minY, ev.y - __.margin.top), strum.maxY);\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n          p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n          m1 = 1 - width / p1[0],\n          b1 = p1[1] * (1 - m1),\n          m2 = 1 - width / p2[0],\n          b2 = p2[1] * (1 - m2); // test if point falls between lines\n\n      return function (p) {\n        var x = p[0],\n            y = p[1],\n            y1 = m1 * x + b1,\n            y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n          brushed = __.data; // Get the ids of the currently active strums.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n            test = containmentTest(strum, strums.width(id)),\n            d1 = strum.dims.left,\n            d2 = strum.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n          svg = pc.selection.select('svg').select('g#strums');\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            strum = strums[strums.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (strum && strum.p1[0] === strum.p2[0] && strum.p1[1] === strum.p2[1]) {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      strums.active = undefined; // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d; // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      }); // Add a new svg group in which we draw the strums.\n\n      pc.selection.select('svg').append('g').attr('id', 'strums').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(strums);\n      drag.on('dragstart', onDragStart(strums)).on('drag', onDrag(strums)).on('dragend', onDragEnd(strums)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#strums').attr('id', 'strum-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      }\n    };\n  })(); // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: angular\n  // code based on 2D.strums.js\n\n\n  (function () {\n    var arcs = {},\n        strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n          id = arc.dims.i,\n          points = [arc.p2, arc.p3],\n          line = svg.selectAll('line#arc-' + id).data([{\n        p1: arc.p1,\n        p2: arc.p2\n      }, {\n        p1: arc.p1,\n        p2: arc.p3\n      }]),\n          circles = svg.selectAll('circle#arc-' + id).data(points),\n          drag = d3.behavior.drag(),\n          path = svg.selectAll('path#arc-' + id).data([arc]);\n      path.enter().append('path').attr('id', 'arc-' + id).attr('class', 'arc').style('fill', 'orange').style('opacity', 0.5);\n      path.attr('d', arc.arc).attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n      line.enter().append('line').attr('id', 'arc-' + id).attr('class', 'arc');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event,\n            angle = 0;\n        i = i + 2;\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (arc.startAngle < Math.PI && arc.endAngle < Math.PI && angle < Math.PI || arc.startAngle >= Math.PI && arc.endAngle >= Math.PI && angle >= Math.PI) {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'arc-' + id).attr('class', 'arc');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            arc;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n        arcs[dims.i] = arc;\n        arcs.active = dims.i; // Make sure that the point is within the bounds\n\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            arc = arcs[arcs.active]; // Make sure that the point is within the bounds\n\n        arc.p2[0] = Math.min(Math.max(arc.minX + 1, ev.x - __.margin.left), arc.maxX);\n        arc.p2[1] = Math.min(Math.max(arc.minY, ev.y - __.margin.top), arc.maxY);\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    } // some helper functions\n\n\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }(); // [0, 2*PI] -> [-PI/2, PI/2]\n\n\n    var signedAngle = function (angle) {\n      var ret = angle;\n\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n\n      return -ret;\n    };\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n\n\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      } // test if segment angle is contained in angle interval\n\n\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n          brushed = __.data; // Get the ids of the currently active arcs.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n            test = containmentTest(arc),\n            d1 = arc.dims.left,\n            d2 = arc.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            a = arcs.width(id),\n            b = y1(d[d1]) - y2(d[d2]),\n            c = hypothenuse(a, b),\n            angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n          svg = pc.selection.select('svg').select('g#arcs');\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            arc = arcs[arcs.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.outerRadius(arcs.length(arcs.active)).startAngle(angle).endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      arcs.active = undefined; // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      }; // returns angles in [-PI/2, PI/2]\n\n\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n            b = p1[1] - p2[1],\n            c = hypothenuse(a, b);\n        return Math.asin(b / c);\n      }; // returns angles in [0, 2 * PI]\n\n\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p2),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n            b = arc.p1[1] - arc.p2[1],\n            c = hypothenuse(a, b);\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d; // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      }); // Add a new svg group in which we draw the arcs.\n\n      pc.selection.select('svg').append('g').attr('id', 'arcs').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(arcs);\n      drag.on('dragstart', onDragStart(arcs)).on('drag', onDrag(arcs)).on('dragend', onDragEnd(arcs)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#arcs').attr('id', 'arc-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  }; // expose a few objects\n\n\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n\n  pc.g = function () {\n    return g;\n  }; // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n\n\n  pc.resize = function () {\n    // selection size\n    pc.selection.select('svg').attr('width', __.width).attr('height', __.height);\n    pc.svg.attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // FIXME: the current brush state should pass through\n\n    if (flags.brushable) pc.brushReset(); // scales\n\n    pc.autoscale(); // axes, destroys old brushes.\n\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  }; // highlight an array of data\n\n\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  }; // clear highlighting\n\n\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  }; // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n\n\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n\n  pc.version = '0.7.0'; // this descriptive text should live with other introspective methods\n\n  pc.toString = function () {\n    return 'Parallel Coordinates: ' + __.dimensions.length + ' dimensions (' + d3.keys(__.data[0]).length + ' total) , ' + __.data.length + ' rows';\n  };\n\n  return pc;\n}\n\nd3.renderQueue = function (func) {\n  var _queue = [],\n      // data to be rendered\n  _rate = 10,\n      // number of calls per frame\n  _clear = function () {},\n      // clearing function\n  _i = 0; // current iteration\n\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n\n    _clear();\n\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true; // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n\n      var end = Math.min(_i + _rate, _queue.length);\n\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  }; // clear the canvas\n\n\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n\n      return rq;\n    }\n\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};","/* [LICENSE TBD] */\n\n/* eslint-disable */\n// from http://bl.ocks.org/3687826\nexport default function (config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]); // header\n\n    selection.selectAll('.header').data([true]).enter().append('div').attr('class', 'header');\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n    header.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n    header.exit().remove(); // rows\n\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n    rows.enter().append('div').attr('class', 'row');\n    rows.exit().remove();\n    var cells = selection.selectAll('.row').selectAll('.cell').data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    }); // cells\n\n    cells.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    cells.exit().remove();\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n}","exports = module.exports = require(\"../../../../../css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"G:/workspace/boke-pro/superset-all/superset/superset-frontend/node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\"],\"names\":[],\"mappings\":\"AAAA,mBAAmB;AACnB;;EAEE,gBAAgB;EAChB,mBAAmB;CACpB;AACD;EACE,qBAAqB;CACtB;;AAED;EACE,WAAW;EACX,gBAAgB;EAChB,aAAa;CACd;;AAED;EACE,kBAAkB;CACnB;AACD;EACE,+BAA+B;CAChC;AACD;EACE,yBAAyB;CAC1B;AACD;EACE,gCAAgC;EAChC,2BAA2B;CAC5B;AACD;;EAEE,WAAW;EACX,aAAa;EACb,4BAA4B;CAC7B;AACD;EACE,WAAW;EACX,8BAA8B;EAC9B,iCAAiC;EACjC,4BAA4B;CAC7B;AACD;EACE,cAAc;CACf;AACD;EACE,4BAA4B;EAC5B,0BAA0B;EAC1B,yBAAyB;EACzB,uBAAuB;EACvB,sBAAsB;EACtB,kBAAkB;EAClB,wBAAwB;CACzB;;AAED,uBAAuB;AACvB;;EAEE,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,aAAa;EACb,YAAY;CACb;AACD;EACE,gCAAgC;CACjC;AACD;EACE,kBAAkB;CACnB;AACD;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;EACpB,aAAa;EACb,aAAa;CACd;AACD;EACE,aAAa;CACd\",\"file\":\"d3.parcoords.css\",\"sourcesContent\":[\"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n"],"sourceRoot":""}